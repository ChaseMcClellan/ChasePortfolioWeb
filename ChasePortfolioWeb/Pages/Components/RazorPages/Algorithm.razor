@page "/Algorithms"
@using Microsoft.AspNetCore.Components.Web

<br>
<link rel="stylesheet" href="~/css/algorithms.css" asp-append-version="true" />

<h3>Algorithms Playground</h3>
<h4>A place where you can interact with some algorithms</h4>
<br />

<h5>Select an Algorithm</h5>
<select @bind="selectedAlgorithm">
    <option value="DigitalRoot">Digital Root</option>
    <option value="Fibonacci">Fibonacci</option>
    <option value="Factorial">Factorial</option>
    <option value="BinarySearch">Binary Search</option>
    <option value="BST">Binary Search Tree Visualization</option>
</select>

<br />
<br />

@if (selectedAlgorithm == "DigitalRoot")
{
    <h5>Digital root in C#</h5>
    <input type="number" @bind="n" />
    <button class="btn-success" @onclick="() => DigitalRootManager()">Go</button>
    <label>Digital root: @rootNumber</label>
}
else if (selectedAlgorithm == "Fibonacci")
{
    <h5>Fibonacci in C#</h5>
    <input type="number" @bind="n" />
    <button class="btn-success" @onclick="() => FibonacciManager()">Go</button>
    <label>Fibonacci number: @fibNumber</label>
}
else if (selectedAlgorithm == "Factorial")
{
    <h5>Factorial in C#</h5>
    <input type="number" @bind="n" />
    <button class="btn-success" @onclick="() => FactorialManager()">Go</button>
    <label>Factorial: @factNumber</label>
}
else if (selectedAlgorithm == "BinarySearch")
{
    <h5>Binary Search in C#</h5>
    <label>Enter a comma-separated list of integers:</label>
    <input type="text" @bind="inputArray" />
    <label>Enter the target number:</label>
    <input type="number" @bind="target" />
    <button class="btn-success" @onclick="() => BinarySearchManager()">Go</button>
    <label>Binary Search result: @binarySearchResult</label>
}else if(selectedAlgorithm == "BST")
{
    <h5>Binary Search Tree Visualization</h5>
    <label>Insert a value:</label>
    <input type="number" @bind="bstValue" />
    <button class="btn-success" @onclick="() => InsertValueIntoBST()">Insert</button>
    
    <h5>BST Structure:</h5>
    <svg width="1000" height="600">
        @foreach (var edge in edges)
        {
            <line x1="@edge.X1" y1="@edge.Y1" x2="@edge.X2" y2="@edge.Y2" stroke="black" stroke-width="2"/>
        }
        @foreach (var node in nodes)
        {
            <circle cx="@node.X" cy="@node.Y" r="20" stroke="black" stroke-width="2" fill="lightblue"/>
           @:<text x="@node.X" y="@node.Y + 5" text-anchor="middle" font-size="12" fill="black">@node.Value</text>
        }
    </svg>
}

@code {
    private string selectedAlgorithm = "DigitalRoot";
    private int n;

    #region DigitalRoot
    private int rootNumber;

    private void DigitalRootManager()
    {
        rootNumber = DigitalRoot(n);
    }

    private int DigitalRoot(int n)
    {
        if (n < 10) return n;
        return DigitalRoot(n % 10 + DigitalRoot(n / 10));
    }
    #endregion

    #region Fibonacci
    private int fibNumber;

    private void FibonacciManager()
    {
        fibNumber = Fibonacci(n);
    }

    private int Fibonacci(int n)
    {
        if (n <= 1) return n;
        return Fibonacci(n - 1) + Fibonacci(n - 2);
    }
    #endregion

    #region Factorial
    private int factNumber;

    private void FactorialManager()
    {
        factNumber = Factorial(n);
    }

    private int Factorial(int n)
    {
        if (n == 0) return 1;
        return n * Factorial(n - 1);
    }
    #endregion

    #region BinarySearch
    private string inputArray; // For comma-separated input
    private int target;
    private string binarySearchResult;

    private void BinarySearchManager()
    {
        try
        {
            // Parse the inputArray and sort it
            int[] array = inputArray.Split(',').Select(int.Parse).OrderBy(x => x).ToArray();
            int resultIndex = BinarySearch(array, target);

            if (resultIndex != -1)
            {
                binarySearchResult = $"Found at index {resultIndex} in the sorted array.";
            }
            else
            {
                binarySearchResult = "Not found in the array.";
            }
        }
        catch
        {
            binarySearchResult = "Invalid input.";
        }
    }

    private int BinarySearch(int[] array, int target)
    {
        int left = 0;
        int right = array.Length - 1;

        while (left <= right)
        {
            int mid = left + (right - left) / 2;

            if (array[mid] == target)
                return mid;

            if (array[mid] < target)
                left = mid + 1;
            else
                right = mid - 1;
        }

        return -1; // If not found
    }
    #endregion

    #region BST
    // BST related variables
    private int bstValue;
    private BSTNode? root;
    private List<BSTNodePosition> nodes = new();
    private List<BSTEdge> edges = new();

    private class BSTNode
    {
        public int Value { get; set; }
        public BSTNode Left { get; set; }
        public BSTNode Right { get; set; }

        public BSTNode(int value)
        {
            Value = value;
        }
    }

    // Struct to represent positions of nodes for rendering in SVG
    private class BSTNodePosition
    {
        public int X { get; set; }
        public int Y { get; set; }
        public int Value { get; set; }
    }

    // Struct to represent edges between nodes in SVG
    private class BSTEdge
    {
        public int X1 { get; set; }
        public int Y1 { get; set; }
        public int X2 { get; set; }
        public int Y2 { get; set; }
    }

    // Insert a value into the BST
    private void InsertValueIntoBST()
    {
        root = InsertNode(root, bstValue);
        nodes.Clear();
        edges.Clear();
        CalculateNodePositions(root, 500, 50, 200);
    }

    // Insert function for the BST
    private BSTNode InsertNode(BSTNode node, int value)
    {
        if (node == null)
            return new BSTNode(value);

        if (value < node.Value)
            node.Left = InsertNode(node.Left, value);
        else if (value > node.Value)
            node.Right = InsertNode(node.Right, value);

        return node;
    }

    // Calculate positions of nodes and edges for visualization
    private void CalculateNodePositions(BSTNode node, int x, int y, int horizontalSpacing)
    {
        if (node == null) return;

        // Add the current node to the list with its position
        nodes.Add(new BSTNodePosition { X = x, Y = y, Value = node.Value });

        // Draw edges to children if they exist
        if (node.Left != null)
        {
            edges.Add(new BSTEdge { X1 = x, Y1 = y, X2 = x - horizontalSpacing / 2, Y2 = y + 80 });
            CalculateNodePositions(node.Left, x - horizontalSpacing / 2, y + 80, horizontalSpacing / 2);
        }
        if (node.Right != null)
        {
            edges.Add(new BSTEdge { X1 = x, Y1 = y, X2 = x + horizontalSpacing / 2, Y2 = y + 80 });
            CalculateNodePositions(node.Right, x + horizontalSpacing / 2, y + 80, horizontalSpacing / 2);
        }
    }
    #endregion
}
